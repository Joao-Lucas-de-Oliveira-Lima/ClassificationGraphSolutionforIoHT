# -*- coding: utf-8 -*-
"""ANN_to_Classification_Graph.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VOmeLwDI4mFjFJmvQUhcXXdkbqEE4NMf

**Import Important Libraries**
"""


import pandas as pd
import numpy as np 
import scipy
from six.moves import urllib
from scipy import stats ##statistic functions
from skl2onnx import convert_sklearn
from skl2onnx.common.data_types import FloatTensorType
import subprocess
import os
import platform

#####################################################################################################################


def trainDecisionTreeModelAllSensors(threshold, testMin, testMax, preprocessingData):
    
    print("===ACC Decision Tree===")
    
    MyNewDataSetTrain_, MyNewDataSetTest_, labelTrain, labelTest, MyNewDataSetTrain, MyNewDataSetTest, labelTrain2, labelTest2, MyNewDataSetTrain2, MyNewDataSetTest2 = preprocessingData
    
    from sklearn import tree
    X, y = MyNewDataSetTrain, labelTrain
    
    cont = 0
    valueAccuracy = 0
    resultModel = None
    while cont < testMin or (valueAccuracy < threshold and cont < testMax) :
        clf = tree.DecisionTreeClassifier()
        clf = clf.fit(X, y)
        tree.plot_tree(clf)

        result = []
        for mndst in  MyNewDataSetTest:
          result.append(clf.predict([mndst]))

        qtd = 0
        for i in range(len(labelTest)):
          if result[i] == labelTest[i]:
            qtd += 1
        
        if valueAccuracy < qtd/len(labelTest):
            valueAccuracy = qtd/len(labelTest)
            resultModel = clf
        cont+=1
   
    print(round(valueAccuracy,2))
    
    print("==== Deision Tree Model Save ====")
    # Specify an initial type for the model ( similar to input shape for the model )
    initial_type = [ 
        ( 'input_study_hours' , FloatTensorType( [None,1] ) ) 
    ]

    # Write the ONNX model to disk
    converted_model = convert_sklearn(resultModel , initial_types=initial_type )
    with open( "sklearn_model_dt.onnx", "wb" ) as f:
        f.write( converted_model.SerializeToString() )

    
    cmd = ['python', '-m', 'onnxruntime.tools.convert_onnx_models_to_ort', 'sklearn_model_dt.onnx']
    shell_cmd = subprocess.run((cmd), capture_output=True, text=True)
    command_output=(shell_cmd.stdout)
    print(command_output)
    
    so = platform.system()
    if so == "Windows":
        os.system('copy sklearn_model_dt.onnx .\\saved_model\\')
        os.system('del sklearn_model_dt.onnx')
    if so == "Linux":
        os.system('mv sklearn_model_dt.onnx saved_model')
        
    print(valueAccuracy)
    return [resultModel,valueAccuracy]

def trainRandomForestModelAllSensors(threshold, testMin, testMax, preprocessingData):
    
    print("===ACC Random Forest===")
    
    MyNewDataSetTrain_, MyNewDataSetTest_, labelTrain, labelTest, MyNewDataSetTrain, MyNewDataSetTest, labelTrain2, labelTest2, MyNewDataSetTrain2, MyNewDataSetTest2 = preprocessingData
    
    from sklearn.ensemble import RandomForestClassifier
    from sklearn import tree
    X, y = MyNewDataSetTrain, labelTrain
    
    cont = 0
    valueAccuracy = 0
    resultModel = None
    while cont < testMin or (valueAccuracy < threshold and cont < testMax):
        clf = RandomForestClassifier(max_depth=11, random_state=0)
        clf = clf.fit(X, y)

        result = []
        for mndst in  MyNewDataSetTest:
          result.append(clf.predict([mndst]))

        qtd = 0
        for i in range(len(labelTest)):
          if result[i] == labelTest[i]:
            qtd += 1
            
        if valueAccuracy < qtd/len(labelTest):
            valueAccuracy = qtd/len(labelTest)
            resultModel = clf
        cont+=1
    
    print(round(valueAccuracy,2))

    print("==== Random Forest Model Save ====")
    # Specify an initial type for the model ( similar to input shape for the model )
    initial_type = [ 
        ( 'input_study_hours' , FloatTensorType( [None,1] ) ) 
    ]

    # Write the ONNX model to disk
    converted_model = convert_sklearn( resultModel , initial_types=initial_type )
    with open( "sklearn_model_rf.onnx", "wb" ) as f:
        f.write( converted_model.SerializeToString() )

    
    cmd = ['python', '-m', 'onnxruntime.tools.convert_onnx_models_to_ort', 'sklearn_model_rf.onnx']
    shell_cmd = subprocess.run((cmd), capture_output=True, text=True)
    command_output=(shell_cmd.stdout)
    
    so = platform.system()
    if so == "Windows":
        os.system('copy sklearn_model_rf.onnx .\\saved_model\\')
        os.system('del sklearn_model_rf.onnx')
    if so == "Linux":
        os.system('mv sklearn_model_rf.onnx saved_model')
        
    return [resultModel,valueAccuracy]
    
if __name__ == '__main__':
    import DatabasePreprocessing1 as dbp1
    print("====Preprocessing====")
    preprocessingData = dbp1.executePreproccessing()
    print("====Training====")
    trainDecisionTreeModelAllSensors(0.7, 10, 1000, preprocessingData)
    trainRandomForestModelAllSensors(0.7, 10, 1000, preprocessingData)
    
'''
def trainLinearRegressionAllSensors(limitLR, testMin, testMax, preprocessingData):
    MyNewDataSetTrain_, MyNewDataSetTest_, labelTrain, labelTest, MyNewDataSetTrain, MyNewDataSetTest, labelTrain2, labelTest2, MyNewDataSetTrain2, MyNewDataSetTest2 = preprocessingData

    #Load a dataset in a Pandas dataframe.
    #train_df = pd.read_csv("project/train.csv")
    #test_df = pd.read_csv("project/test.csv")

    train_df = pd.DataFrame(MyNewDataSetTrain_, columns = ["Mean ACC", "MAX ACC", "MIN ACC", "STD ACC", "Kurtosis ACC", "Skewness ACC", "Entropy ACC", "MAD ACC", "IQR ACC","Mean GYR", "MAX GYR", "MIN GYR", "STD GYR", "Kurtosis GYR", "Skewness GYR", "Entropy GYR", "MAD GYR", "IQR GYR", "Movement"])
    test_df = pd.DataFrame(MyNewDataSetTest_, columns = ["Mean ACC", "MAX ACC", "MIN ACC", "STD ACC", "Kurtosis ACC", "Skewness ACC", "Entropy ACC", "MAD ACC", "IQR ACC","Mean GYR", "MAX GYR", "MIN GYR", "STD GYR", "Kurtosis GYR", "Skewness GYR", "Entropy GYR", "MAD GYR", "IQR GYR", "Movement"])

    from statistics import stdev

    count = 0
    values = []
    for a in MyNewDataSetTrain_:
      if count > 0:
        value = 0.0 
        for b in a[0:17]:
          value+=float(b)
        values.append([str(value),str(int(a[18]))])
      else:
        count+=1
    dtTrain = np.array(values)

    traindf = pd.DataFrame(dtTrain, columns = ["Values", "Result"])

    count = 0
    values = []
    for a in MyNewDataSetTest_:
      if count > 0:
        value = 0.0 
        for b in a[0:17]:
          value+=float(b)
        values.append([value,str(int(a[18]))])
      else:
        count+=1

    media = 0
    valores = []
    for b in values:
      media += b[0]
      valores.append(b[0])
    media = media/len(valores)

    stddev = stdev(valores)
    for b in values:
      b[0] = str((b[0] - media)/stddev)

    dtTest = np.array(values)

    testdf = pd.DataFrame(dtTest, columns = ["Values", "Result"])

    from sklearn.linear_model import LinearRegression


    X , y = traindf.values[ : , 0 ] , traindf.values[ : , 1 ]
    X = np.expand_dims( X , axis=1 )

    # Fitting the linear regression model
    regressor = LinearRegression()
    regressor.fit( X , y )

    # Make predictions
    print( f'Prediction for 8.5 hours is {regressor.predict([[12]])[0]}' )
'''